# -*- coding: utf-8 -*-
"""
/***************************************************************************
 WDNAnalysis
                                 A QGIS plugin
 WDNAnalysis
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2021-09-25
        git sha              : $Format:%H$
        copyright            : (C) 2021 by WDNAnalysis
        email                : WDNAnalysis
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, QVariant
from qgis.PyQt.QtGui import QIcon,QPixmap
from qgis.PyQt.QtWidgets import QAction, QFileDialog,QSizePolicy
from qgis.core import QgsRasterLayer,QgsVectorLayer,QgsProject,QgsGeometry,QgsPoint, QgsFeatureRequest, QgsExpression, QgsFeature,QgsField,Qgis
import processing
from osgeo import gdal
from qgis.gui import QgsMessageBar

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .WDNAnalysis_dialog import WDNAnalysisDialog
import os.path


class WDNAnalysis:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'WDNAnalysis_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&WDNAnalysis')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('WDNAnalysis', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/WDNAnalysis/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u''),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&WDNAnalysis'),
                action)
            self.iface.removeToolBarIcon(action)

    def selectOutputNetwork(self):
    
        filename,_filter=QFileDialog.getOpenFileName(self.dlg,"select Network file","",'ShapeFile(*.shp)')
        self.dlg.lineNetwork.setText(filename)
        win=self.iface.mainWindow()
       
        if not filename or filename=='':
            return
    def selectOutputDEM(self):
    
        filename,_filter=QFileDialog.getOpenFileName(self.dlg,"select DEM file","",'geoTif(*.tif)')
        self.dlg.lineDEM.setText(filename)
        win=self.iface.mainWindow()
       
        if not filename or filename=='':
            return 
     

    def FillJunkionsAltitudeAndSlope(self):

        slope_layer = QgsProject.instance().mapLayersByName('Slope')[0]
        dem_layer = QgsProject.instance().mapLayersByName('dem')[0]
        junktions=QgsProject.instance().mapLayersByName('junktions')[0]
        #retreive altitude value from DEM file and affect it to junction points
        junktions_altitude=processing.run("native:rastersampling", {'INPUT': junktions,'RASTERCOPY': dem_layer,'COLUMN_PREFIX':'altitude','OUTPUT': 'TEMPORARY_OUTPUT'})["OUTPUT"]
        #retreive slope value from Slope layer and affect it to junction points
        junktions_altitude_slope=processing.run("native:rastersampling", {'INPUT': junktions_altitude,'RASTERCOPY': slope_layer,'COLUMN_PREFIX':'slope','OUTPUT': 'memory:junctions_altitude_slope'})["OUTPUT"]
        

        QgsProject.instance().addMapLayer(junktions_altitude_slope)
        self.dlg.bar.pushMessage("", "Junctions are Filled succefully",level=Qgis.Success)    
        
    def CreateJunkions(self):
    
        #water Network layer opning       
        line_layer=(QgsProject.instance().mapLayersByName('WDN')[0])
        #MultiLine String to  LineString
        wdn=processing.run("native:multiparttosingleparts", {'INPUT': line_layer, 'OUTPUT': 'memory:water distribution network' })["OUTPUT"]
        #new layer of juctions
        point_layer = QgsVectorLayer("Point?crs=epsg:32760", "point_layer", 'memory')
        #Remove duplicated points
        junktions=processing.run("native:deleteduplicategeometries", {'INPUT': point_layer, 'OUTPUT': 'memory:junktions' })["OUTPUT"]   
        
        pr = junktions.dataProvider()
        pr1 = wdn.dataProvider()
        junktions.startEditing()
        wdn.startEditing()
        
        pr.addAttributes([ QgsField("id", QVariant.Int), QgsField("x", QVariant.Double), QgsField("y", QVariant.Double)])
        pr1.addAttributes([ QgsField("start_id", QVariant.Int), QgsField("end_id", QVariant.Int)])
        i=0
        
        wdn.commitChanges()
        wdn.startEditing()
        
        junktions.commitChanges()
        junktions.startEditing()
        
        #loop over Network polylines and creating junctions
        
        for feature in wdn.getFeatures():
            #create a new feature of type type junction
            feat = QgsFeature(junktions.fields())
            geom = feature.geometry().asPolyline()
            #create new  start end points :j unctions
            start_point = QgsPoint(geom[0])
            end_point = QgsPoint(geom[-1])
            
            feat.setGeometry(start_point)
            feat["id"]=i
            #retreiving the x,y coordinates of polyline start end points and a affect it to x,y columns of junction
            feat["x"]=start_point.x()
            feat["y"]=start_point.y()
            #adding end start feature
            pr.addFeatures([feat])
            #update the start_id of polyline with the id of the start junction
            feature["start_id"]=i
            wdn.updateFeature(feature)
            i+=1
            
            feat.setGeometry(end_point)
            feat["id"]=i
            feat["x"]=end_point.x()
            feat["y"]=end_point.y()
            #adding end point feature
            pr.addFeatures([feat])
            feature["end_id"]=i
            wdn.updateFeature(feature)
            i+=1
            
        junktions.commitChanges()
        wdn.commitChanges()
        #add junctions and network layers 
        QgsProject.instance().addMapLayer(junktions)
        QgsProject.instance().addMapLayer(wdn)
        
        self.dlg.pushFill.setEnabled(True)
        self.dlg.pushJunkions.setEnabled(False)
        self.dlg.bar.pushMessage("", "Network Created  succefully",level=Qgis.Success)    
      
    #loading layers  
    def LoadLayers(self):
        
        QgsProject.instance().removeAllMapLayers()
        dem=QgsRasterLayer(self.dlg.lineDEM.text(), "dem")
        wdn=QgsVectorLayer(self.dlg.lineNetwork.text(), "WDN")
        vald=''
        #testing if layers are valid
        if not dem.isValid():
            vald='DEM'
        if not wdn.isValid():
            vald=vald+' WDN'
        
        if len(vald)==0:
        
            QgsProject.instance().addMapLayer(dem)
            QgsProject.instance().addMapLayer(wdn)
            
            self.dlg.pushSlope.setEnabled(True)
        else:
            self.dlg.bar.pushMessage("", "The follwing layers are not valid :"+vald,level=Qgis.Warning)
            
    #generating the slope layer        
    def CreateSlope(self):
    
        #DEM layer creation from loaded layers
        dem=(QgsProject.instance().mapLayersByName('dem')[0])
        processing.runAndLoadResults("native:slope", {'INPUT': dem, 'Z_FACTOR':1, 'OUTPUT':'TEMPORARY_OUTPUT'})['OUTPUT']
        
        self.dlg.pushSlope.setEnabled(False)
        self.dlg.pushJunkions.setEnabled(True)
        self.dlg.bar.pushMessage("", "Slope is generated succefully",level=Qgis.Success)    
         
         
 
        
    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg = WDNAnalysisDialog()
            
            self.dlg.bar = QgsMessageBar()
            self.dlg.bar.setSizePolicy(QSizePolicy.Minimum, QSizePolicy.Fixed)
            self.dlg.gridLayout_3.addWidget(self.dlg.bar, 0, 0, 1, 1)
            
            
            icon= ':/plugins/WDNAnalysis/icons/folder.png'
            pixIcon=QPixmap(icon)
            self.dlg.pushNetwork.setIcon(QIcon(QPixmap(icon)))
            self.dlg.pushDEM.setIcon(QIcon(QPixmap(icon)))
            
            
            self.dlg.pushNetwork.clicked.connect(self.selectOutputNetwork)
            self.dlg.pushDEM.clicked.connect(self.selectOutputDEM)
            
            self.dlg.pushLoad.clicked.connect(self.LoadLayers)
            icon= ':/plugins/WDNAnalysis/icons/layers.png'
            pixIcon=QPixmap(icon)
            self.dlg.pushLoad.setIcon(QIcon(QPixmap(icon)))
            
            self.dlg.pushFill.clicked.connect(self.FillJunkionsAltitudeAndSlope)
            icon= ':/plugins/WDNAnalysis/icons/fill.png'
            pixIcon=QPixmap(icon)
            self.dlg.pushFill.setIcon(QIcon(QPixmap(icon)))
            
            self.dlg.pushSlope.clicked.connect(self.CreateSlope)
            icon= ':/plugins/WDNAnalysis/icons/slope.png'
            pixIcon=QPixmap(icon)
            self.dlg.pushSlope.setIcon(QIcon(QPixmap(icon)))
            
            self.dlg.pushJunkions.clicked.connect(self.CreateJunkions)
            icon= ':/plugins/WDNAnalysis/icons/network.png'
            pixIcon=QPixmap(icon)
            self.dlg.pushJunkions.setIcon(QIcon(QPixmap(icon)))
            
            
   
        # show the dialog
        self.dlg.show()
        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:
            # Do something useful here - delete the line containing pass and
            # substitute with your code.
            pass
